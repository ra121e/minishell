src/builtin.c:	if (!ft_strncmp(ms->cmd[0], "export", 7))
src/builtin.c://	if (!ft_strncmp(ms->cmd[0], "echo", 5))
src/builtin.c://	else if (!ft_strncmp(ms->cmd[0], "cd", 3))
src/builtin.c://	else if (!ft_strncmp(ms->cmd[0], "pwd", 4))
src/builtin.c://	else if (!ft_strncmp(ms->cmd[0], "export", 7))
src/builtin.c://	else if (!ft_strncmp(ms->cmd[0], "unset", 6))
src/builtin.c://	else if (!ft_strncmp(ms->cmd[0], "env", 4))
src/builtin.c://	else if (!ft_strncmp(ms->cmd[0], "exit", 5))
src/builtin_env.c:	while (ms->envp[i])
src/builtin_env.c:	ms->cmd_envp = malloc(sizeof (char *) * (i + 1));
src/builtin_env.c:	if (ms->cmd_envp == NULL)
src/builtin_env.c:	while (ms->envp[++i])
src/builtin_env.c:		ms->cmd_envp[i] = ms->envp[i]->pair;
src/builtin_env.c:	ms->cmd_envp[i] = NULL;
src/builtin_env.c:	ms->envp = malloc(sizeof(t_envp) * (i + 1));
src/builtin_env.c:	if (!ms->envp)
src/builtin_env.c:		ms->envp[i] = malloc(sizeof(t_envp));
src/builtin_env.c:		if (!ms->envp[i])
src/builtin_env.c:		ms->envp[i]->key = ft_substr(envp[i], 0, j);
src/builtin_env.c:		ms->envp[i]->value= ft_substr(envp[i], j + 1, ft_strlen(envp[i]) - j);
src/builtin_env.c:		ms->envp[i]->pair = ft_strdup(envp[i]);
src/builtin_env.c:	ms->envp[i] = malloc(sizeof(t_envp));
src/builtin_env.c:	if (!ms->envp[i])
src/builtin_env.c:	ms->envp[i] = 0;
src/builtin_export.c:	if (!ms->key || (ms->key[0] != '_' && !ft_isalpha(ms->key[0])))
src/builtin_export.c:		while (ms->key[++i])
src/builtin_export.c:			if (ms->key[i] != '_' && !ft_isalnum(ms->key[i]))
src/builtin_export.c:		ft_dprintf(2, "export: `%s': not a valid identifier\n", ms->pair);
src/builtin_export.c:		free(ms->key);
src/builtin_export.c:		free(ms->value);
src/builtin_export.c:		free(ms->pair);
src/builtin_export.c:	ms->eq = 0;
src/builtin_export.c:	ms->key = 0;
src/builtin_export.c:	ms->value = 0;
src/builtin_export.c:	ms->pair = 0;
src/builtin_export.c:			ms->eq = i;
src/builtin_export.c:	if (ms->eq)
src/builtin_export.c:		ms->key = ft_substr(str, 0, ms->eq);
src/builtin_export.c:		ms->value = ft_strdup(str + ms->eq + 1);
src/builtin_export.c:		ms->pair = ft_strsjoin(3, ms->key, "=", ms->value);
src/builtin_export.c:		ms->key = ft_strdup(str);
src/builtin_export.c:		ms->value = 0;
src/builtin_export.c:		ms->pair = ft_strdup(str);
src/builtin_export.c:	while (ms->cmd[++i])
src/builtin_export.c:		update_if_valid(ms, ms->cmd[i]);
src/builtin_export_helper.c:	if (!ms->cmd[1])
src/builtin_export_helper.c:		while (ms->envp[++i])
src/builtin_export_helper.c:			if (!ms->envp[i]->value)
src/builtin_export_helper.c:				printf("declare -x %s\n", ms->envp[i]->key);
src/builtin_export_helper.c:			else if (!ft_strncmp(ms->envp[i]->value, "", 1))
src/builtin_export_helper.c:				printf("declare -x %s=\"\"\n", ms->envp[i]->key);
src/builtin_export_helper.c:				printf("declare -x %s=\"%s\"\n", ms->envp[i]->key, ms->envp[i]->value);
src/builtin_export_helper.c:	ms->envp = malloc(sizeof(t_envp) * (i + 2));
src/builtin_export_helper.c:	if (!ms->envp)
src/builtin_export_helper.c:		ms->envp[i] = malloc(sizeof(t_envp));
src/builtin_export_helper.c:		if (!ms->envp[i])
src/builtin_export_helper.c:		ms->envp[i] = envp[i];
src/builtin_export_helper.c:	ms->envp[i] = malloc(sizeof(t_envp));
src/builtin_export_helper.c:	if (!ms->envp[i])
src/builtin_export_helper.c:	ms->envp[i]->key = ms->key;
src/builtin_export_helper.c:	ms->envp[i]->value = ms->value;
src/builtin_export_helper.c:	ms->envp[i]->pair = ms->pair;
src/builtin_export_helper.c:	ms->envp[++i] = 0;
src/builtin_export_helper.c:	ms->len = ft_strlen(ms->key);
src/builtin_export_helper.c:	while (ms->envp[++i])
src/builtin_export_helper.c:		if (!ft_strncmp(ms->envp[i]->key, ms->key, ms->len + 1))
src/builtin_export_helper.c:			if (!ms->envp[i]->value || ms->value)
src/builtin_export_helper.c://				ms->envp[i]->key = ms->key;
src/builtin_export_helper.c:				ms->envp[i]->value = ms->value;
src/builtin_export_helper.c:				ms->envp[i]->pair = ms->pair;
src/builtin_export_helper.c:	if (!ms->envp[i])
src/builtin_export_helper.c:		export_add(ms, ms->envp);
src/cleanup.c:	free(ms->prompt);
src/error.c:	ft_putstr_fd(ms->cmd[0], 2);
src/error.c:	free_split(ms->cmd);
src/exec_cmd.c:	if (ms->fd_r > 2)
src/exec_cmd.c:		dup2_and_close(ms->fd_r, STDIN_FILENO);
src/exec_cmd.c:	execve(ms->cmd[0], ms->cmd, ms->cmd_envp);
src/exec_cmd.c:	cmd_exe = get_fullpath(ms->cmd[0], ms);
src/exec_cmd.c:	execve(cmd_exe, ms->cmd, ms->cmd_envp);
src/exec_cmd.c:	perror(ms->cmd[0]);
src/exec_cmd.c:	free(ms->cmd);
src/exec_cmd.c:	if (is_builtin(ms->cmd[0]) == true)
src/exec_cmd.c:		ms->builtin_cmd = 1;
src/exec_cmd.c://		printf("built in command: %s\nfunction WIP\n", ms->cmd[0]);
src/exec_cmd.c:		ms->pid = pid;
src/exec_cmd.c:	if (ms->fd_r > 2)
src/exec_cmd.c:		close(ms->fd_r);
src/exec_cmd.c:	ms->fd_r = fd_w[0];
src/exec_cmd.c:		ms->fd_r = get_filename_fd(ms, (*cur)->str, ms->fd_r, READ);
src/exec_cmd.c:	ms->cmd[0] = cur->str;
src/exec_cmd.c:			if (ms->cmd_error)
src/exec_cmd.c:			ms->cmd[i++] = cur->str;
src/exec_cmd.c:	ms->cmd[i] = NULL;
src/exec_cmd.c:	ms->cmd_error = 0;
src/exec_cmd.c:	ms->builtin_cmd = 0;
src/exec_cmd.c:	ms->fd_w_malloc = 0;
src/exec_cmd.c:			if (ms->cmd_error)
src/exec_cmd.c:			if (ms->cmd_error)
src/exec_cmd.c://TODO:	free ms->cmd, ms->fd_w (if malloced)
src/exec_cmd.c:	if (ms->fd_w_malloc)
src/exec_cmd.c:		free(ms->fd_w);
src/exec_cmd_helper.c:	ms->cmd = malloc(sizeof(char *) * (i + 1));
src/exec_cmd_helper.c:	if (!ms->cmd)
src/exec_cmd_helper.c:		perror("ms->cmd malloc error");//malloc error
src/exec_cmd_helper.c:	ms->fd_w = malloc(sizeof(int) * 2);
src/exec_cmd_helper.c:	ms->fd_w[0] = 0;
src/exec_cmd_helper.c:	ms->fd_w[1] = 1;
src/exec_cmd_helper.c:	ms->fd_w_malloc = 1;
src/exec_cmd_helper.c:	return (ms->fd_w);
src/exec_cmd_helper.c:		ms->cmd_error = 1;
src/exec_cmd_helper.c:		if (ms->fd_w_malloc)
src/exec_cmd_helper.c:			free(ms->fd_w);
src/expansion.c:	ms->tmp_node = cur->right;
src/expansion.c:	ms->front = 0;
src/expansion.c:	ms->back = 0;
src/expansion.c:			ms->front = cur;
src/expansion.c:			ms->front = ms->back;
src/expansion.c:		ms->back = newnode(split[i]);
src/expansion.c:		ms->front->right = ms->back;
src/expansion.c:	ms->back->right = ms->tmp_node;
src/expansion.c:		if (ms->expand_var && cur)
src/expansion_var.c:		ms->len += get_var_len(ms, "$?");
src/expansion_var.c://		ms->len += ft_itoa(ms->exit_status);
src/expansion_var.c:	ms->start = ++i;
src/expansion_var.c:	if (i == ms->start)
src/expansion_var.c:	ms->var = ft_substr(str, ms->start, i - ms->start);
src/expansion_var.c:	if (!ms->var)
src/expansion_var.c:		perror("ms->var malloc error\n");
src/expansion_var.c:	ms->len += get_var_len(ms, ms->var);
src/expansion_var.c:	free(ms->var);
src/expansion_var.c:				ms->len++;
src/expansion_var.c:					ms->len++;
src/expansion_var.c:			ms->len++;
src/expansion_var.c:	ms->start = ++i;
src/expansion_var.c:	if (i == ms->start)
src/expansion_var.c:		ms->new_str[ms->n++] = '$';
src/expansion_var.c:	ms->var = ft_substr(str, ms->start, i - ms->start);
src/expansion_var.c:	if (!ms->var)
src/expansion_var.c:		perror("ms->var malloc error\n");
src/expansion_var.c:	ms->var_value = get_var(ms, ms->var);
src/expansion_var.c:	if (ms->var_value)
src/expansion_var.c:		ms->end = 0;
src/expansion_var.c:		while (ms->var_value[ms->end])
src/expansion_var.c:			ms->new_str[ms->n++] = ms->var_value[ms->end++];
src/expansion_var.c:		if (!ft_strncmp(ms->var, "$?", 3))
src/expansion_var.c:			free(ms->var_value);
src/expansion_var.c:			ms->expand_var = 1;
src/expansion_var.c:	free(ms->var);
src/expansion_var.c:	ms->n = 0;
src/expansion_var.c:				ms->new_str[ms->n++] = str[i];
src/expansion_var.c:					ms->new_str[ms->n++] = str[i];
src/expansion_var.c:			ms->new_str[ms->n++] = str[i];
src/expansion_var.c:	ms->new_str[ms->n] = 0;
src/expansion_var.c:	ms->len = 0;
src/expansion_var.c:	ms->expand_var = 0;
src/expansion_var.c:	ms->new_str = malloc(ms->len + 1);
src/expansion_var.c:	if (!ms->new_str)
src/expansion_var.c:		perror("ms->new_str malloc error\n");//malloc protection
src/expansion_var.c:	cur->str = ms->new_str;
src/get_fullpath.c: * @param[in] ms->cmd_envp environment variable as 3rd argument from command line
src/get_fullpath.c: * @fn char	**find_ms->cmd_envpath
src/get_fullpath.c: * @brief find "PATH=" int the ms->cmd_envp, and cut by [:] into substring
src/get_fullpath.c: * @param[in] ms->cmd_envp
src/get_fullpath.c:	while (ms->cmd_envp[i])
src/get_fullpath.c:		if (ft_strncmp(ms->cmd_envp[i], "PATH=", 5) == 0)
src/get_fullpath.c:			envpath = ms->cmd_envp[i] + 5;
src/get_fullpath.c:	if (ms->cmd_envp[i] == NULL)
src/get_fullpath.c: * @param[in] ms->cmd_envp enviroment variable storing PATH
src/get_fullpath.c: 	- find_envpath: find "PATH=" in the string from ms->cmd_envp
src/helper.c:		var = ft_itoa(ms->exit_status);
src/helper.c:	while (ms->envp[++i])
src/helper.c:		if (!ft_strncmp(ms->envp[i]->key, var, ft_strlen(var) + 1))
src/helper.c:			return (ft_strlen(ms->envp[i]->value));
src/helper.c:		var = ft_itoa(ms->exit_status);
src/helper.c:	while (ms->envp[++i])
src/helper.c:		if (!ft_strncmp(ms->envp[i]->key, var, ft_strlen(var) + 1))
src/helper.c:			return (ms->envp[i]->value);
src/init.c:	ms->head = 0;
src/init.c:	ms->start = 0;
src/init.c:	ms->len = 0;
src/init.c:	ms->end = 0;
src/init.c:	ms->key = 0;
src/init.c:	ms->fd_r = 0;
src/init.c:	ms->pid = 0;
src/init.c:	ms->exit_status = 0;
src/init.c:	ms->prompt = ft_strsjoin(5, "\001\033[35m\002", get_var(ms, "USER"), \
src/init.c:	if (!ms->prompt)
src/init.c:		perror("ms->prompt malloc error");//malloc protection
src/lexer.c:			ms->len++;
src/lexer.c:				ms->len++;
src/lexer.c:			ms->len += 3;
src/lexer.c:			ms->len += 2;
src/lexer.c:		ms->len++;
src/lexer.c:	ms->str = malloc(ms->len + 1);
src/lexer.c:	if (!ms->str)
src/lexer.c:		perror("ms->new_str malloc error");//malloc protection
src/lexer.c:	ms->n = 0;
src/lexer.c:	ms->i = -1;
src/lexer.c:	while (str[++ms->i])
src/lexer.c:		if (str[ms->i] == '\'' || str[ms->i] == '\"')
src/lexer.c:			ms->c = str[ms->i];
src/lexer.c:			ms->str[ms->n++] = str[ms->i];
src/lexer.c:			while (str[++ms->i] != ms->c)
src/lexer.c:				ms->str[ms->n++] = str[ms->i];
src/lexer.c:			ms->str[ms->n++] = str[ms->i];
src/lexer.c:		else if (operator_char_count(str, ms->i) > 10)
src/lexer.c:			ms->str[ms->n++] = ' ';
src/lexer.c:			if (operator_char_count(str, ms->i) > 20)
src/lexer.c:				ms->str[ms->n++] = str[ms->i++];
src/lexer.c:			ms->str[ms->n++] = str[ms->i];
src/lexer.c:			ms->str[ms->n++] = ' ';
src/lexer.c:			ms->str[ms->n++] = str[ms->i];
src/lexer.c:	ms->str[ms->n] = 0;
src/lexer.c:	ms->end++;
src/lexer.c:	while (ms->str[ms->end] != c)
src/lexer.c:		ms->end++;
src/lexer.c:	ms->end++;
src/lexer.c:	ms->end = 0;
src/lexer.c:	while (ms->end <= ms->len)
src/lexer.c:		if (ms->str[ms->end] == '\'' || ms->str[ms->end] == '\"')
src/lexer.c:			quote(ms, ms->str[ms->end]);
src/lexer.c:		else if (!ms->str[ms->end] || ft_isspace(ms->str[ms->end]))
src/lexer.c:			if (!ms->end)
src/lexer.c:				ms->start = ++ms->end;
src/lexer.c:			else if (!ft_isspace(ms->str[ms->end - 1]))
src/lexer.c:				ms->start = ++ms->end;
src/lexer.c:			ms->end++;
src/lexer.c:	ms->token = ft_strdup("");
src/lexer.c:	free(ms->str);
src/minishell.c:	if (ms->head)
src/minishell.c:		while (ms->head)
src/minishell.c:			printf("%s", ms->head->str);
src/minishell.c:			if (ms->head->next)
src/minishell.c:			ms->head = ms->head->next;
src/minishell.c:		ms->input = readline(ms->prompt);
src/minishell.c:		if (!ms->input)
src/minishell.c:		else if (!*ms->input)
src/minishell.c:			add_history(ms->input);
src/minishell.c:			lexer(ms, ms->input);
src/minishell.c:		free(ms->input);
src/minishell.c:		ms->start_node = parser(&ms->head);
src/minishell.c://		printAST(ms->start_node, 0, 0);
src/minishell.c:		traverse_start(ms->start_node, ms);
src/tokenize.c:	if (operator_char_count(ms->str, ms->start) == 21)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_AND);
src/tokenize.c:	else if (operator_char_count(ms->str, ms->start) == 22)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_OR);
src/tokenize.c:	else if (operator_char_count(ms->str, ms->start) == 23)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_REDIRECT_HEREDOC);
src/tokenize.c:	else if (operator_char_count(ms->str, ms->start) == 24)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_REDIRECT_APPEND);
src/tokenize.c:	else if (operator_char_count(ms->str, ms->start) == 11)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_PIPE);
src/tokenize.c:	else if (operator_char_count(ms->str, ms->start) == 12)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_REDIRECT_IN);
src/tokenize.c:	else if (operator_char_count(ms->str, ms->start) == 13)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_REDIRECT_OUT);
src/tokenize.c:	else if (operator_char_count(ms->str, ms->start) == 14)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_LPAREN);
src/tokenize.c:	else if (operator_char_count(ms->str, ms->start) == 15)
src/tokenize.c:		tokenize_word(ms, ms->str, TK_RPAREN);
src/tokenize.c:		tokenize_word(ms, ms->str, TK_WORD);
src/tokenize.c:	ms->token = ft_substr(str, ms->start, ms->end - ms->start);
src/tokenize.c:	ms->start = ++ms->end;
src/tokenize.c:	cur = new_token(ms->token, kind);
src/tokenize.c:	add_back(&ms->head, cur);
src/traverse.c:	waitpid(ms->pid, &status, 0);
src/traverse.c:	if (ms->cmd_error)
src/traverse.c:		ms->exit_status = 1;
src/traverse.c:	else if (!ms->builtin_cmd)
src/traverse.c:		ms->exit_status = WEXITSTATUS(status);
src/traverse.c:		if (!ms->exit_status)
src/traverse.c:		if (ms->exit_status)
